/*!
*
* \file   raptor_test.cpp
*
* \brief  Implementation of raptor codes data operation APIs
*
*
* \par    Include files
*         -     
*
* \par    Copyright (c) 2011 Yeqing Wu
*
* This library is free software; you can redistribute it and/or modify it 
* under the terms of the GNU Lesser General Public License as published by 
* the Free Software Foundation. This software is developed by refering to the software wrote by Vicente Sirvent,
* but many parts(especially some critical parts) of the raptor codes in that software have not been implemented 
* and there are lots of bugs and logical errors in that software. So I re-design software and implement it.
*
*
* This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
* See the GNU Lesser General Public License for more details.
* You should have received a copy of the GNU Lesser General Public License along with this library; 
* if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
* 
* \version 
* Revision of last commit: $Rev$ 
* Author of last commit  : $Author$ 
* Date of last commit    : $Date$ 
*
*/

#include <stdio.h>
#include <stdlib.h>
#include <vector>

#include "raptor_defines.h"
#include "raptor_triple.h"
#include "raptor_types.h"
#include "raptor_encoder_api.h"
#include "raptor_decoder_api.h"

using std::vector;

#define random(x) (rand()%x)

U32 test_triple_generator(void)
{
	CTripleGenerator gen;
	U32 k = 1024;
	for (U32 x = 0 ; x < k; ++x)
	{
		CTriple triple = gen.Trip(k,x);
	}
	return 0;
}

queue<CData> encoder_test(U32 k, U32 dataLen, U32 lossNum)
{
	RaptorEncoder encoder(k, lossNum);

	printf("Source symbols numbers: %d\n", k);
	printf("\nSource symbols generated by random:\n");
	U32 index = 0;
	for (U32 i = 0; i < k; ++i)
	{
		vector<U8> rndData;
		rndData.reserve(dataLen);
		for (U32 j = 0; j < dataLen; ++j)
		{
			rndData.push_back(random(256));

#ifdef TEST_PURPOSE
			index++;
			printf("%6d", rndData[j]);
			if ((index % SHOW_NUMS) == 0)
			{
				printf("\n");
			}
#endif
		}
		encoder.set_data(rndData);
	}

	encoder.get_data_access();

	queue<CData> res;
	index = 0;
	U8 *buf = new U8[dataLen];
	while (!encoder.is_empty())
	{
		vector<U8> recover_data = encoder.get_encodedSym();
		for (S32 i = 0; i < dataLen; ++i)
		{
			buf[i] = recover_data[i];
		}
		
		CData data(buf, dataLen);
		res.push(data);

#ifdef TEST_PURPOSE
		for (U32 j = 0; j < dataLen; ++j)
		{

			index++;
			printf("%6d", recover_data[j]);
			if ((index % SHOW_NUMS) == 0)
			{
				printf("\n");
			}
		}
#endif

	}
	delete [] buf;
	buf = NULL;

	return res;
}

U32 decoder_test(U32 k, S32 T, U32 *lossDataIndex, U32 N, U32 lossNum, queue<CData> &receivedSym)
{
	RaptorDecoder decoder(k, N, lossNum);
	bool isFound = false;
	for (U32 i = 0; i < N; ++i)
	{
		isFound = false;
		for (U32 j = 0; j < lossNum; ++j)
		{
			if (i == lossDataIndex[j])
			{
				isFound = true;
				break;	
			}
			else 
			{
				isFound = false;
			}
		}
		if (isFound == false)
		{
			decoder.set_ESI(i);
		}
	}

	while (!receivedSym.empty())
	{
		CData data = receivedSym.front();
		vector<U8> encoded_data(data.GetData(), data.GetData() + data.GetLen());
		decoder.set_data(encoded_data);
		receivedSym.pop();
	}
	
	decoder.decode();

#ifdef TEST_PURPOSE
	S32 dateLen = decoder.recoveredSym.front().GetLen();
	size_t symbols_num = decoder.recoveredSym.size();
	printf("Decoded symbols numbers: %d\n", symbols_num);
	printf("Decoded symbols:\n");
	U32 index = 0;
#endif

	while (!decoder.is_empty())
	{
		vector<U8> recover_data = decoder.get_decodedSym();
#ifdef TEST_PURPOSE
		S32 data_size = recover_data.size();
		for (U32 j = 0; j < data_size; ++j)
		{
			index++;
			printf("%6d", recover_data[j]);
			if ((index % SHOW_NUMS) == 0)
			{
				printf("\n");
			}
		}
#endif
	}

	return 0;
}

S32 compare (const void* a, const void* b)
{
	return (*(S32* )a - *(S32* )b );
}

int main(int argc, char* argv[])
{
	U32 k = 0;
	U32 dataLen = 0;
	U32 lossNum = 0;
	queue<CData> encoded_sym;


	printf("Input the number of source symbols: ");
	scanf("%d",&k);

	printf("Input the length of every source symbol(be multiples of 2): ");
	scanf("%d", &dataLen);

	printf("Input the loss data number: ");
	scanf("%d", &lossNum);

	printf("--------------------------Encoder-----------------------------\n");
	encoded_sym = encoder_test(k, dataLen, lossNum);


	U32 encodedSymSize = encoded_sym.size();
	printf("\nEncoded Packet Total Numbers: %d\n", encodedSymSize);

	U32 *lossDataIndex = new U32[lossNum];

	U32 lossIndex = 0;
	lossDataIndex[lossIndex++] = random(encodedSymSize);

	while (lossIndex < lossNum)
	{
		S32 randNum = random(encodedSymSize);
		bool isFound = false;
		for (S32 i = 0; i < lossNum; ++i)
		{
			if (randNum == lossDataIndex[i])
			{
				isFound = true;
				break;
			}
		}
		if (!isFound)
		{
			lossDataIndex[lossIndex++] = randNum;
		}
	}

	qsort (lossDataIndex, lossNum, sizeof(U32), compare);

	for (U32 lossIndex = 0; lossIndex < lossNum; ++lossIndex)
	{
		printf("Lost Packet Index: %d\n", lossDataIndex[lossIndex]);
	}

	printf("\n\n\n--------------------------Decoder-----------------------------\n");
	decoder_test(k, dataLen, lossDataIndex, encodedSymSize, lossNum, encoded_sym);

	return 0;
}